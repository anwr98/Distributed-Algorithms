# -*- coding: utf-8 -*-
"""EX2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14Uz2KZc_nYNftVWR_z6ptYuz_pl8u2AL
"""

print("Anwr Sied Ahmd")
print("206710212")

print("תוכנית 1")

import random
import networkx as nx
import matplotlib.pyplot as plt

class Node:
    def __init__(self, uid, n):
        self.uid = uid  # Unique ID of the node
        self.incoming = None  # Incoming message
        self.outgoing = uid  # Outgoing message initially set to UID
        self.is_leader = False
        self.next_node = None  # Pointer to the next node in the ring
        self.n = n

    def process(self):
        """Process the incoming message and decide the outgoing message."""
        if self.incoming is not None:
            # If the incoming UID is larger than current UID, propagate it
            if self.incoming > self.uid:
                self.outgoing = self.incoming
            # If the incoming UID matches the current UID, declare as leader
            elif self.incoming == self.uid:
                self.is_leader = True
            # Otherwise, drop the message
            self.incoming = None

    def send_message(self):
        """Send the outgoing message to the next node."""
        if self.next_node:
            self.next_node.incoming = self.outgoing


class LCR:
    def __init__(self, n, init_n):
        self.n = n
        self.init_n = init_n
        self.nodes = []
        self.create_ring()

    def create_ring(self):
        """Create the ring of nodes with unique UIDs."""
        uids = random.sample(range(1, 1000), self.n)  # Generate unique UIDs
        for uid in uids:
            self.nodes.append(Node(uid, self.n))

        # Link the nodes to form a ring
        for i in range(self.n):
            self.nodes[i].next_node = self.nodes[(i + 1) % self.n]

    def visualize_ring(self):
        """Visualize the ring graph."""
        graph = nx.DiGraph()
        for i, node in enumerate(self.nodes):
            graph.add_node(node.uid)
            graph.add_edge(node.uid, self.nodes[(i + 1) % self.n].uid)

        pos = nx.circular_layout(graph)
        nx.draw(graph, pos, with_labels=True, node_size=3000, font_size=12, font_color="white", node_color="blue")
        plt.title("Ring Graph")
        plt.show()

    def run(self):
        """Run the LCR algorithm."""
        # Visualize the initial ring
        print("Initial ring configuration:")
        self.visualize_ring()

        # Initialize the process with a random subset of nodes
        initiators = random.sample(self.nodes, self.init_n)
        initiator_ids = [node.uid for node in initiators]
        print(f"Init node is [ {', '.join(map(str, initiator_ids))} ]")
        for node in initiators:
            node.outgoing = node.uid

        # Iterate until a leader is elected
        while not any(node.is_leader for node in self.nodes):
            # Each node processes incoming messages and sends outgoing messages
            for node in self.nodes:
                node.process()
            for node in self.nodes:
                node.send_message()

        # Identify the leader
        leader = next(node for node in self.nodes if node.is_leader)
        print(f"{leader.uid} knows it is The leader")

        # Display messages from all nodes
        for node in self.nodes:
            print(f"{node.uid} knows that: The leader is {leader.uid}")

        # Visualize the final ring with the leader highlighted
        self.visualize_leader(leader.uid)

        # Final message
        print("All processes terminated")

    def visualize_leader(self, leader_uid):
        """Visualize the ring graph with the leader highlighted."""
        graph = nx.DiGraph()
        for i, node in enumerate(self.nodes):
            graph.add_node(node.uid)
            graph.add_edge(node.uid, self.nodes[(i + 1) % self.n].uid)

        pos = nx.circular_layout(graph)
        colors = ["green" if node == leader_uid else "blue" for node in graph.nodes()]
        nx.draw(graph, pos, with_labels=True, node_size=3000, font_size=12, font_color="white", node_color=colors)
        plt.title("Ring Graph with Leader Highlighted")
        plt.show()

# Main execution
if __name__ == "__main__":
    random.seed(100)  # Set random seed for reproducibility

    # Parameters
    n = 100  # Size of the ring (>= 3)
    init_n = 2  # Number of initial active nodes (>= 1)

    # Run the LCR algorithm
    lcr = LCR(n, init_n)
    lcr.run()

print("תוכנית 2")

import multiprocessing
import random
import networkx as nx
import matplotlib.pyplot as plt

def node_process(node_id, n, my_graph, recv_pipe, send_pipes, root_pipe=None):
    """Process representing a node in the graph"""
    status = "UNKNOWN"  # Initial status of the node
    root = None  # Root node ID

    if root_pipe:  # If this node is the initiating node
        status = "ROOT"
        root = node_id
        print(f"{node_id} [ROOT] :: I am the ROOT")
        # Send message to connected nodes
        for neighbor in range(n):
            if my_graph[node_id][neighbor]:
                send_pipes[neighbor].send((node_id, node_id))

    while True:
        msg = recv_pipe.recv()  # Receive message
        if msg == "STOP":
            break

        sender, sender_root = msg

        if status == "UNKNOWN":
            status = "PROCESS"
            root = sender_root
            print(f"{node_id} [PROCESS] :: {root} is the ROOT")
            # Send message to connected nodes
            for neighbor in range(n):
                if my_graph[node_id][neighbor]:
                    send_pipes[neighbor].send((node_id, root))

    if status == "UNKNOWN":
        print(f"{node_id} [SATURATED] :: {root} is the ROOT")

def saturation_algorithm(n, my_graph, init_node):
    """Run the Saturation algorithm on the graph"""
    # Create pipes for inter-process communication
    pipes = [multiprocessing.Pipe() for _ in range(n)]
    recv_pipes, send_pipes = zip(*pipes)

    # Create processes for each node
    processes = []
    for i in range(n):
        root_pipe = send_pipes[i] if i == init_node else None
        p = multiprocessing.Process(
            target=node_process,
            args=(i, n, my_graph, recv_pipes[i], send_pipes, root_pipe),
        )
        processes.append(p)
        p.start()

    # Send initial message from the root node
    if init_node is not None:
        for neighbor in range(n):
            if my_graph[init_node][neighbor]:
                send_pipes[neighbor].send((init_node, init_node))

    # Terminate all processes
    for pipe in send_pipes:
        pipe.send("STOP")

    for p in processes:
        p.join()

    print("All processes terminated")
    visualize_graph(n, my_graph, init_node)


def visualize_graph(n, my_graph, init_node):
    """Visualize the graph using networkx"""
    graph = nx.Graph()
    for i in range(n):
        for j in range(i + 1, n):
            if my_graph[i][j]:
                graph.add_edge(i, j)

    pos = nx.spring_layout(graph)
    nx.draw(
        graph,
        pos,
        with_labels=True,
        node_size=700,
        font_size=12,
        node_color=["green" if i == init_node else "blue" for i in range(n)],
    )
    plt.title("Graph Visualization")
    plt.show()

if __name__ == "__main__":
    # Input number of nodes
    n = int(input("Enter number of nodes (n >= 3): "))
    while n < 3:
        n = int(input("Invalid input. Enter number of nodes (n >= 3): "))

    # Input adjacency matrix
    print("Enter adjacency matrix (n*n):")
    my_graph = []
    for i in range(n):
        row = list(map(int, input(f"Row {i + 1}: ").strip().split()))
        my_graph.append([bool(x) for x in row])

    # Input initial node
    init_node = int(input(f"Enter initial node (0 to {n - 1}): "))
    while not (0 <= init_node < n):
        init_node = int(input(f"Invalid input. Enter initial node (0 to {n - 1}): "))

    # Run the algorithm
    saturation_algorithm(n, my_graph, init_node)

